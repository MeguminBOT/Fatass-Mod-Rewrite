package;

import flixel.tweens.FlxTween;
import flixel.tweens.FlxEase;
import haxe.Json;
import flixel.graphics.FlxGraphic;
import flixel.util.FlxColor;
import flixel.math.FlxPoint;
import flixel.group.FlxGroup.FlxTypedGroup;
import flixel.text.FlxText;
import flixel.group.FlxSpriteGroup;
import flixel.FlxSprite;
import flixel.FlxG;
import flixel.math.FlxRect;
import openfl.events.MouseEvent;
import haxe.Http;
import haxe.zip.Entry;
#if sys
import sys.thread.Thread;
import sys.io.File;
import sys.FileSystem;
#end

using StringTools;

private typedef DownloadMetadata = {
    var link:String;
    //lfs = large file storage, this is a github thing
    var ?lfs:Bool;
    var ?organization:String;
    var ?branch:String;
    var ?repoName:String;
    var ?file_name:String;
}

private class SpriteEdit extends FlxSprite{
    public var x_callback:Float->Void;
    public var y_callback:Float->Void;
    public var width_callback:Float->Void;
    public var height_callback:Float->Void;

    public function new(x:Float, y:Float, xx:Float->Void, yy:Float->Void, width:Float->Void, height:Float->Void) {
        this.x_callback = xx;
        this.y_callback = yy;
        this.width_callback = width;
        this.height_callback = height;

        super(x, y);
    }

    override function set_x(n:Float):Float{
        x_callback(n);

        return super.set_x(n);
    }

    override function set_y(n:Float):Float {
        y_callback(n);

        return super.set_y(n);
    }

    override function set_width(n:Float):Float {
        width_callback(n);

        return super.set_width(n);
    }

    override function set_height(n:Float):Float {
        height_callback(n);

        return super.set_height(n);
    }

    public function graphicCreate(Width:Int, Height:Int, Color:FlxColor = FlxColor.WHITE, Unique:Bool = false, ?Key:String):SpriteEdit{
        var graph:FlxGraphic = FlxG.bitmap.create(Width, Height, Color, Unique, Key);
		frames = graph.imageFrame;
        return this;
    }
}

private class DownloadSubState extends MusicBeatSubstate {
    //its literally one object, why not?
    public var screenOverlay:FlxSprite;
    public var text:FlxText;
    public var modName:String;

    public function new(modName:String){
        super();

        this.modName = modName;
    }

    override function create(){
        super.create();

        screenOverlay = new FlxSprite().makeGraphic(FlxG.width, FlxG.height, FlxColor.BLACK);
        screenOverlay.alpha = 0;
        add(screenOverlay);

        text = new FlxText(0, 0, 0, 'Downloading: $modName', 25);
        text.x = (FlxG.width / 2) - (text.width / 2);
        text.y = (FlxG.height / 2) - (text.height / 2);
        text.alpha = 0;
        add(text);
    }
}

//copied from denpa engine, this class was made by yanni :fancee:. works well, no bloat.
private class ZipHandler 
{
    public static function saveUncompressed(zip_Path:String, save_path:String):Void {
        var zipReader = new haxe.zip.Reader(File.read(zip_Path));
        var file_list:haxe.ds.List<Entry> = zipReader.read();

        if(!save_path.endsWith('/')) save_path += '/';
        if(!FileSystem.exists('${save_path}')) FileSystem.createDirectory('${save_path}');

        for(file in file_list) {
            if(file.fileName.endsWith('/')) { FileSystem.createDirectory(save_path + file.fileName); continue; }
            final fileData:Null<haxe.io.Bytes> = uncompressFile(file);

            File.saveBytes(save_path + file.fileName, fileData);
        }
    }

    /**
     * For readability altered version of original haxe.zip.unzip function, takes from reader produced entry and uncompresses it.
     * @param file The file to uncompress, can be generated by creating a new entry list using `new Reader(File.read(filePath)).read()` and then looping through the list.
     * @return `Null<haxe.io.Bytes>` -> The uncompressed bytes of the parameter file.
     */
    public static function uncompressFile(file:Entry):Null<haxe.io.Bytes> {
        if(!file.compressed)
			return file.data; //File is already uncompressed

		var c = new haxe.zip.Uncompress(-15);
		var s = haxe.io.Bytes.alloc(file.fileSize);
		var r = c.execute(file.data,0,s,0);
		c.close();
		if( !r.done || r.read != file.data.length || r.write != file.fileSize )
			throw 'Invalid compressed data for ${file.fileName}';
		file.compressed = false;
		file.dataSize = file.fileSize;
		file.data = s;
        return file.data;
    }
}

class DataContainer extends FlxSpriteGroup{
	public var name:String;
    public var text:FlxText;
    public var black:SpriteEdit;
    public var rect:FlxRect;

    public function new(name:String, width:Float, height:Float){
        super();
        this.name = name;
        this.width = width;
        this.height = height;

        rect = new FlxRect(0, 0, 0, 0);

        black = new SpriteEdit(0, 0,  (n:Float) -> {rect.x = n;}, 
        (n:Float) -> {rect.y = n;}, 
        (n:Float) -> {rect.width = n;},
        (n:Float) -> {rect.height = n;}).graphicCreate(Std.int(width), Std.int(height), flixel.util.FlxColor.BLACK);
        text = new FlxText(black.x / 2, black.y / 2, 0, name, 15);
        black.alpha = 0.5;

        add(black);
        add(text);
    }

}

class ContainerList extends FlxTypedGroup<DataContainer> {
    public var containers:Array<DataContainer>;

    public function new(containers:Array<DataContainer>){
        super();
        this.containers = containers;

        for (container in containers){
            container.rect = new FlxRect(container.x, container.y, container.width, container.height);
            add(container);
        }
    }

    //cool math
    public function center():Void {
		// get mid screen
		final p:FlxPoint = new FlxPoint(FlxG.width / 2, FlxG.height / 2);
		// either one or two
		var middleSprites:Array<DataContainer> = [];

		// even number
		if (containers.length % 2 == 0)
		{
			middleSprites.push(containers[Std.int(containers.length / 2 - 1)]);
			middleSprites.push(containers[Std.int(containers.length / 2)]);
		}
		else
			middleSprites.push(containers[Std.int(containers.length / 2)]);

		for (i in 0...middleSprites.length)
		{
			final quiteMidModNgl:DataContainer = middleSprites[i];
            final x:Float = (FlxG.width / 2) - (quiteMidModNgl.width / 2);
            final y:Float = (FlxG.height / 2) - (quiteMidModNgl.height / 2);

			if (middleSprites.length == 1)
			{
                quiteMidModNgl.x = x;
				quiteMidModNgl.y = y;
				break;
			}

			quiteMidModNgl.x = x;
            quiteMidModNgl.y = y + ((i == 0) ? 0 : middleSprites[i - 1].height);
		}

		p.put();
	}
}

class DownloadModsState extends MusicBeatState
{
    var list:ContainerList;
    var containers:Array<DataContainer> = [];

    //this contains an array of links
    //name => link
    var modsOnGithub:Map<String, DownloadMetadata> = ["RNF Modpack for Testing" => {link: "https://github.com/MeguminBOT/Fatass-Mod-Download-Test/releases/download/test/rnf.zip", organization: "MeguminBOT", repoName: "Fatass-Mod-Download-Test", branch: "main", file_name: "rnf.zip", lfs: true}];

    var can_click:Bool = true;

    private function retrieve_href_from_lfs(raw_link_branch:String, batch_link:String):{href:String, ?size:Int} {
		var req = new haxe.Http(raw_link_branch);
		var ret:Dynamic = {href: "", size: 0};

		req.onData = function(data)
		{
			final sha:String = data.split("\n")[1].split(":")[1];
			final size:Int = Std.parseInt(data.split("\n")[2].split(" ")[1]);

			final stuff = Json.stringify({
				operation: "download",
				transfer: ["basic"],
				objects: [{oid: sha, size: size}],
				hash_algo: "sha256"
			});

			var newOne = new Http(batch_link);
			newOne.setHeader("Content-type", "application/vnd.git-lfs+json");
			newOne.setHeader("Accept", "application/vnd.git-lfs+json");

			newOne.setPostData(stuff);

			newOne.onData = function(dat)
				ret = {href: Json.parse(dat).objects[0].actions.download.href, size: size};

			newOne.onError = function(e) throw e;

			newOne.request(true);
		}

		req.onError = function(error) 
            trace(error);

		req.request(false);

        if (ret != "")
            return ret;
        else
            throw "Return for this function was not specified, an error may have occured."; 
    }

    override function create(){
        FlxG.mouse.visible = true;

        for (mod in modsOnGithub.keys()){
            var item:DataContainer = new DataContainer(mod, 500, 100);
            containers.push(item);
        }

        var bg = new FlxSprite().loadGraphic(Paths.image("menuBGBlue"));
        add(bg);

        list = new ContainerList(containers);
        list.center();
        add(list);

        FlxG.stage.addEventListener(MouseEvent.MOUSE_DOWN, (event:MouseEvent) ->{
            final p:FlxPoint = new FlxPoint(event.localX, event.localY);
            for (item in list.containers){
                if (item.rect.containsPoint(p)){
                    Thread.create(function(){
						final meta:DownloadMetadata = modsOnGithub.get(item.name);
						// substitute
						var raw_github_repo_link = meta.link.replace("https://github.com/", "https://raw.githubusercontent.com/");

						var size:Int;

						// deal with it here
						if (meta.lfs)
						{
							final formed_string = 'https://raw.githubusercontent.com/${meta.organization}/${meta.repoName}/${meta.branch}/${meta.file_name}';

							final batch_string = 'https://github.com/${meta.organization}/${meta.repoName}.git/info/lfs/objects/batch';

							final thingamajig:{href:String, size:Int} = retrieve_href_from_lfs(formed_string, batch_string);
							size = thingamajig.size;
							raw_github_repo_link = thingamajig.href;
						}

						var http:Http = new Http(raw_github_repo_link);

                        final sub = new DownloadSubState(item.name);
                        openSubState(sub);

						http.onBytes = (data:haxe.io.Bytes) ->
						{
                            if (!FileSystem.exists('mods/${meta.file_name}')){
                                
                                if (data.length == size){
                                    File.saveBytes('mods/${meta.file_name}', data);
                                    //extract
                                    ZipHandler.saveUncompressed('mods/${meta.file_name}', 'mods/${meta.file_name.replace(".zip", "")}');
                                    //delete zip file
                                    FileSystem.deleteFile('mods/${meta.file_name}');
                                    sub.close();
                                    return;
                                }
                            }else{
                                return;
                            }
						}

						http.onError = (err:String) ->
						{
							throw err;
						};

						http.request(false);
                    });
                }
            }
        });

        super.create();
    }
}